'use strict';

const subscribe = require('./subscribe');
const { isClass, getClassName } = require('./utils');
const getHandledMessageTypes = require('./utils/getHandledMessageTypes');
const nullLogger = require('./utils/nullLogger');
const readEventsFromIterator = require('./utils/readEventsFromIterator');

/**
 * @param {any} type
 * @returns {IAggregateConstructor | undefined}
 */
const asAggregateConstructor = type => (isClass(type) ? type : undefined);

/**
 * Aggregate command handler.
 *
 * Subscribes to event store and awaits aggregate commands.
 * Upon command receiving creates an instance of aggregate,
 * restores its state, passes command and commits emitted events to event store.
 *
 * @class AggregateCommandHandler
 * @implements {ICommandHandler}
 */
class AggregateCommandHandler {

	/**
	 * Creates an instance of AggregateCommandHandler.
	 *
	 * @param {object} options
	 * @param {IEventStore} options.eventStore
	 * @param {ISnapshotStorage} [options.snapshotStorage]
	 * @param {IAggregateConstructor | IAggregateFactory} options.aggregateType
	 * @param {string[]} [options.handles]
	 * @param {ILogger} [options.logger]
	 */
	constructor({ eventStore, snapshotStorage, aggregateType, handles, logger = nullLogger }) {
		if (!eventStore) throw new TypeError('eventStore argument required');
		if (!aggregateType) throw new TypeError('aggregateType argument required');

		this._eventStore = eventStore;
		this._logger = logger;
		this._snapshotStorage = snapshotStorage;

		const AggregateType = asAggregateConstructor(aggregateType);
		if (AggregateType) {
			/** @type {IAggregateFactory} */
			this._aggregateFactory = params => new AggregateType(params);
			this._handles = getHandledMessageTypes(AggregateType);
		}
		else {
			if (!Array.isArray(handles) || !handles.length) throw new TypeError('handles argument must be an non-empty Array');

			/** @type {IAggregateFactory} */
			// @ts-ignore
			this._aggregateFactory = aggregateType;
			this._handles = handles;
		}
	}

	/**
	 * Subscribe to all command types handled by aggregateType
	 *
	 * @param {ICommandBus} commandBus
	 * @returns {any} - whatever EventEmitter.on returns for each messageType
	 */
	subscribe(commandBus) {
		subscribe(commandBus, this, {
			messageTypes: this._handles,
			masterHandler: c => this.execute(c)
		});
	}

	/**
	 * Restore aggregate from event store events
	 *
	 * @private
	 * @param {Identifier} id
	 * @returns {Promise<IAggregate>}
	 */
	async _restoreAggregate(id) {
		const snapshot = this._snapshotStorage ? await this._snapshotStorage.getSnapshot(id) : undefined;
		const eventsFilter = snapshot && { afterEvent: snapshot.lastEvent };
		const events = await readEventsFromIterator(await this._eventStore.getStream(id, eventsFilter));

		const aggregate = this._aggregateFactory({ id, snapshot, events });

		this._logger.log('info', `${aggregate} state restored from ${events}`, { service: getClassName(aggregate) });

		return aggregate;
	}

	/**
	 * Create new aggregate with new Id generated by event store
	 *
	 * @private
	 * @returns {Promise<IAggregate>}
	 */
	async _createAggregate() {
		const id = await this._eventStore.getNewId();
		const aggregate = this._aggregateFactory({ id });
		this._logger.log('info', `${aggregate} created`, { service: getClassName(aggregate) });

		return aggregate;
	}

	/**
	 * Pass a command to corresponding aggregate
	 *
	 * @param {ICommand} cmd - command to execute
	 * @return {Promise<IEventStream>} events
	 */
	async execute(cmd) {
		if (!cmd) throw new TypeError('cmd argument required');
		if (!cmd.type) throw new TypeError('cmd.type argument required');

		const aggregate = cmd.aggregateId ?
			await this._restoreAggregate(cmd.aggregateId) :
			await this._createAggregate();

		const handlerResponse = aggregate.handle(cmd);
		if (handlerResponse instanceof Promise)
			await handlerResponse;

		const events = aggregate.changes;
		this._logger.log('info', `${aggregate} "${cmd.type}" command processed, ${events} produced`, { service: getClassName(aggregate) });
		if (!events.length)
			return events;

		await this._eventStore.commit(aggregate.id, events);

		if (this._snapshotStorage && aggregate.shouldTakeSnapshot) {
			if (typeof aggregate.makeSnapshot !== 'function')
				throw new TypeError('aggregate.makeSnapshot must be a Function');

			const snapshot = aggregate.makeSnapshot();

			this._snapshotStorage.saveSnapshot(aggregate.id, snapshot);
		}

		return events;
	}
}

module.exports = AggregateCommandHandler;
